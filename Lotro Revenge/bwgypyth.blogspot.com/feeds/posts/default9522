<?xml version='1.0' encoding='UTF-8'?><rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:openSearch="http://a9.com/-/spec/opensearchrss/1.0/" xmlns:blogger="http://schemas.google.com/blogger/2008" xmlns:georss="http://www.georss.org/georss" xmlns:gd="http://schemas.google.com/g/2005" xmlns:thr="http://purl.org/syndication/thread/1.0" version="2.0"><channel><atom:id>tag:blogger.com,1999:blog-5998090735925918818</atom:id><lastBuildDate>Thu, 08 Oct 2020 20:30:29 +0000</lastBuildDate><title>lotro revenge</title><description>A blog about gathering internal information about LOTRO.</description><link>http://bwgypyth.blogspot.com/</link><managingEditor>noreply@blogger.com (bwgypyth)</managingEditor><generator>Blogger</generator><openSearch:totalResults>35</openSearch:totalResults><openSearch:startIndex>1</openSearch:startIndex><openSearch:itemsPerPage>25</openSearch:itemsPerPage><item><guid isPermaLink="false">tag:blogger.com,1999:blog-5998090735925918818.post-5443309192279437670</guid><pubDate>Mon, 07 Nov 2016 12:03:00 +0000</pubDate><atom:updated>2016-11-07T04:08:40.764-08:00</atom:updated><title>HowTo: Understand 0B000002 vs. 0B004002 packets</title><description>The&amp;nbsp;0B000002 and&amp;nbsp;0B004002 are both ping pong packets (i.e. they are exchanged between client and server without any user input, just to confirm the connection works). What makes them really interesting is that they are quite different, but very similar.&lt;br /&gt;&lt;br /&gt;Let me explain: The 0B000002 has 18 bytes of body, while the 0B004002 has 22 bytes, a difference of four bytes. The body if 0B004002 is offset by these 4 bytes.&lt;br /&gt;&lt;br /&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;Meaning&lt;/th&gt;&lt;th&gt;Bytes 0B000002&lt;/th&gt;&lt;th&gt;Bytes 0B004002&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Sequence number of the last packet seen from &quot;the other side&quot;&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;td&gt;0x14 - 0x17&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Value specified in the 01000006 packet sent by the server&lt;/td&gt;&lt;td&gt;0x14 - 0x17&lt;/td&gt;&lt;td&gt;0x18 - 0x1b&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Unknown, but constantly increasing number&lt;/td&gt;&lt;td&gt;0x18 - 0x1b&lt;/td&gt;&lt;td&gt;0x1c - 0x1f&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Client/Server uptime?&lt;/td&gt;&lt;td&gt;0x1c - 0x21&lt;/td&gt;&lt;td&gt;0x20 - 0x25&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Byteswapped confirmation that a packet group was received (e.g. 0x0000ebff will be sent by the client, when all packets of the group ffeb are received)&lt;/td&gt;&lt;td&gt;0x12 - 0x25&lt;/td&gt;&lt;td&gt;0x26 - 0x29&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;br /&gt;&lt;div&gt;As you can see both packets share the same payload, but the&amp;nbsp;0B004002 one also ships upfront the sequence number of the last packet received by the other side of the communication.&lt;/div&gt;</description><link>http://bwgypyth.blogspot.com/2016/11/howto-understand-0b000002-vs-0b004002.html</link><author>noreply@blogger.com (bwgypyth)</author><thr:total>48</thr:total></item><item><guid isPermaLink="false">tag:blogger.com,1999:blog-5998090735925918818.post-3639260371353766285</guid><pubDate>Tue, 01 Nov 2016 23:35:00 +0000</pubDate><atom:updated>2016-11-01T16:36:12.141-07:00</atom:updated><title>HowTo: Read the first packet sent by the server</title><description>The first packet sent by the server back to the client can be understood as follows:&lt;br /&gt;&lt;br /&gt;Header:&lt;br /&gt;&lt;div&gt;&lt;br /&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;Bytes&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;th&gt;Length&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;0x00-0x01&lt;/th&gt;&lt;td&gt;Set to the session ID of the server&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;0x02-0x03&lt;/th&gt;&lt;td&gt;The length of the packets body in bytes&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;0x04-0x07&lt;/th&gt;&lt;td&gt;The command (aka action aka OP code): 04000000&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;0x08-0x0B&lt;/th&gt;&lt;td&gt;The sequence number of the packet: 00000000&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;0x0C-0x0F&lt;/th&gt;&lt;td&gt;The checksum of the packets body&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;0x10-0x11&lt;/th&gt;&lt;td&gt;Unknown initial value&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;0x12-0x13&lt;/th&gt;&lt;td&gt;Unknown initial value&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;br /&gt;&lt;div&gt;Body:&lt;br /&gt;&lt;br /&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;Bytes&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;th&gt;Length&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;0x14-0x17&lt;/th&gt;&lt;td&gt;Base value for &quot;ping pong&quot; packets, though byte-swapped&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;0x18-0x1b&lt;/th&gt;&lt;td&gt;Unknown&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;0x1c-0x23&lt;/th&gt;&lt;td&gt;Some kind of session key (returned byte swapped in the next packet from the client)&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;0x24-0x25&lt;/th&gt;&lt;td&gt;Padding: 00 00&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;0x26-0x27&lt;/th&gt;&lt;td&gt;Session ID for the client (will be the first 2 bytes of every next packet from the client)&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;0x28-0x2b&lt;/th&gt;&lt;td&gt;Base for the checksum generation on the server&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;0x2c-0x2f&lt;/th&gt;&lt;td&gt;Base for the checksum generation on the client&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;0x30-0x3f&lt;/th&gt;&lt;td&gt;Some constant (same for every account, every server)&lt;/td&gt;&lt;td&gt;16&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;div&gt;That&#39;s all currently known behind the magic happening in the first packet from the server.&lt;/div&gt;&lt;/div&gt;</description><link>http://bwgypyth.blogspot.com/2016/11/the-first-packet-sent-by-server-back-to.html</link><author>noreply@blogger.com (bwgypyth)</author><thr:total>2</thr:total></item><item><guid isPermaLink="false">tag:blogger.com,1999:blog-5998090735925918818.post-8409634553745179564</guid><pubDate>Tue, 01 Nov 2016 23:25:00 +0000</pubDate><atom:updated>2016-11-01T16:25:27.183-07:00</atom:updated><title>HowTo: Read the first packet sent by the client</title><description>The first packet sent by the client to the server can be understood as follows:  &lt;br /&gt;&lt;br /&gt;Header:&lt;br /&gt;&lt;br /&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;Bytes&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;th&gt;Length&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;0x00-0x01&lt;/th&gt;&lt;td&gt;Set to 00 00 (no session ID yet)&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;0x02-0x03&lt;/th&gt;&lt;td&gt;The length of the packets body in bytes&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;0x04-0x07&lt;/th&gt;&lt;td&gt;The command (aka action aka OP code): 00010000&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;0x08-0x0B&lt;/th&gt;&lt;td&gt;The sequence number of the packet: 00000000&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;0x0C-0x0F&lt;/th&gt;&lt;td&gt;The checksum of the packets body&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;0x10-0x11&lt;/th&gt;&lt;td&gt;00 00&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;0x12-0x13&lt;/th&gt;&lt;td&gt;00 00&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;br /&gt;&lt;div&gt;Body:&lt;br /&gt;&lt;br /&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;Bytes&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;th&gt;Length&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;0x14&lt;/th&gt;&lt;td&gt;Length of the following (ASCII) string&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;0x15-0x53&lt;/th&gt;&lt;td&gt;The client version &quot;061004_netver:...&quot; as ASCII string&lt;/td&gt;&lt;td&gt;63&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;0x54-0x57&lt;/th&gt;&lt;td&gt;Length of the following block (0x0145 bytes, byte swapped)&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;0x58-0x5B&lt;/th&gt;&lt;td&gt;Unknown?&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;0x5C-0x5F&lt;/th&gt;&lt;td&gt;Set to 04 00 00 00 if a GLS ticket follows&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;0x60-0x63&lt;/th&gt;&lt;td&gt;Seconds since 1970, bytes must be read &quot;backwards&quot;&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;0x64&lt;/th&gt;&lt;td&gt;Length of the following (UTF-16) string&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;0x65-0x96&lt;/th&gt;&lt;td&gt;The account identifier? (a GUID/UUID in UTF-16)&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;0x97-0x9a&lt;/th&gt;&lt;td&gt;GLS ticket length (byte swapped) 0x0102 == 258 bytes&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;0x9b-0x19c&lt;/th&gt;&lt;td&gt;GLS ticket generated by the launcher&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;div&gt;That&#39;s all currently known behind the magic happening in the first packet.&lt;/div&gt;</description><link>http://bwgypyth.blogspot.com/2016/11/howto-read-first-packet-sent-by-client.html</link><author>noreply@blogger.com (bwgypyth)</author><thr:total>1</thr:total></item><item><guid isPermaLink="false">tag:blogger.com,1999:blog-5998090735925918818.post-1629446192650098598</guid><pubDate>Sun, 30 Oct 2016 13:04:00 +0000</pubDate><atom:updated>2016-11-07T04:09:59.824-08:00</atom:updated><title>HowTo: Understanding a packet header</title><description>Let&#39;s take a look at some of the packets we already know and understand. First of a few basics as a reminder:&lt;br /&gt;&lt;ol&gt;&lt;li&gt;each and every packet has a header and a body&lt;/li&gt;&lt;li&gt;the header is fixed size, the body is variable in size&lt;/li&gt;&lt;li&gt;the header is fixed in content, the body varies&lt;/li&gt;&lt;/ol&gt;&lt;div&gt;For now let&#39;s focus on what we know about the header.&lt;/div&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;Bytes&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;th&gt;Length&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;0x00-0x01&lt;/th&gt;&lt;td&gt;The session ID. The server and the client each have a session ID.&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;0x02-0x03&lt;/th&gt;&lt;td&gt;The length of the packets body in bytes&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;0x04-0x07&lt;/th&gt;&lt;td&gt;The command (aka action aka OP code) this packet will perform&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;0x08-0x0B&lt;/th&gt;&lt;td&gt;The sequence number of the packet (necessary for ordering UDP packets)&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;0x0C-0x0F&lt;/th&gt;&lt;td&gt;The checksum of the packets body&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;0x10-0x11&lt;/th&gt;&lt;td&gt;Packet group number (e.g. 0xffeb, confirmed in the&amp;nbsp;08004002 packet)&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;0x12-0x13&lt;/th&gt;&lt;td&gt;Unclear, get increased by the server&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description><link>http://bwgypyth.blogspot.com/2016/10/howto-understanding-packet-header.html</link><author>noreply@blogger.com (bwgypyth)</author><thr:total>0</thr:total></item><item><guid isPermaLink="false">tag:blogger.com,1999:blog-5998090735925918818.post-7070949002104471470</guid><pubDate>Fri, 28 Oct 2016 23:28:00 +0000</pubDate><atom:updated>2016-10-28T16:28:32.147-07:00</atom:updated><title>HowTo: Capture decrypted packets</title><description>To get decrypted packets for further analysis, you can easily capture and decrypt them using the LOTRO-Tools.&lt;br /&gt;&lt;br /&gt;First of all clone the git repository from&amp;nbsp;https://gitlab.com/lotro/server.&lt;br /&gt;&lt;br /&gt;Open the Solution &quot;LOTRO-Tools.sln&quot; in Monodevelop or Visual Studio.&lt;br /&gt;&lt;br /&gt;Build the project&amp;nbsp;LOTROPacketCaptureAndAutoDecryption and launch it from bin/Debug/LOTROPacketCaptureAndAutoDecryption.exe&lt;br /&gt;&lt;br /&gt;Look into the subfolder decrypted_packets for available files. The files contain a single packet each. The filename is like the following:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;4 digits represent the sequential number of captured packets&lt;/li&gt;&lt;li&gt;the text &quot;client&quot; says it was a packet sent by the client, the text &quot;server&quot; indicates it was a packet from the server&lt;/li&gt;&lt;li&gt;the last 8 digits describe the action to be performed by the packet&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;Examples:&lt;/div&gt;&lt;div&gt;0000_client-00010000 is the first package captured (sequence starts at 0000), was sent from the client and contains the action 00010000&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;0001_server-00040000 is the second package captured, was sent by the server and contains the action 00040000&lt;/div&gt;</description><link>http://bwgypyth.blogspot.com/2016/10/howto-capture-decrypted-packets.html</link><author>noreply@blogger.com (bwgypyth)</author><thr:total>0</thr:total></item><item><guid isPermaLink="false">tag:blogger.com,1999:blog-5998090735925918818.post-6382942080685965970</guid><pubDate>Fri, 28 Oct 2016 21:23:00 +0000</pubDate><atom:updated>2016-10-28T14:23:36.811-07:00</atom:updated><title>HowTo: Use LOTRO-Tools on Linux</title><description>LOTRO-Tools was developed on Windows using winpcap. It fails on Linux because SharpPcap is erroneously looking for &quot;libwpcap.so&quot; (as it would look for wpcap.dll on Windows), while it should look for &quot;libpcap.so&quot; instead. You can work around that using&lt;br /&gt;&lt;br /&gt;sudo ln -s /usr/lib/libpcap.so /usr/lib/libwpcap.so</description><link>http://bwgypyth.blogspot.com/2016/10/howto-use-lotro-tools-on-linux.html</link><author>noreply@blogger.com (bwgypyth)</author><thr:total>0</thr:total></item><item><guid isPermaLink="false">tag:blogger.com,1999:blog-5998090735925918818.post-54612006639288423</guid><pubDate>Fri, 28 Oct 2016 19:48:00 +0000</pubDate><atom:updated>2016-10-28T12:48:28.396-07:00</atom:updated><title>HowTo: Capture the appropriate packets between the client and the server</title><description>To only capture the packets necessary for analysis of the game protocol (i.e. not the chat protocol), you can use the following pcap (e.g. Wireshark) filter:&lt;br /&gt;&lt;br /&gt;!broadcast and !multicast and udp and !port 53 and !port 59511 and !port 161 and !port 2900 and !port 5355</description><link>http://bwgypyth.blogspot.com/2016/10/howto-capture-appropriate-packets.html</link><author>noreply@blogger.com (bwgypyth)</author><thr:total>0</thr:total></item><item><guid isPermaLink="false">tag:blogger.com,1999:blog-5998090735925918818.post-6382893859997082434</guid><pubDate>Fri, 28 Oct 2016 19:34:00 +0000</pubDate><atom:updated>2016-10-28T12:34:12.170-07:00</atom:updated><title>HowTo: Disabling checksum checks in the LOTRO client</title><description>To test a local server that does not support checksumming, you can patch you lotroclient.exe&lt;br /&gt;&lt;br /&gt;Go to position: 3B 4C 24 1C 75 6A 8B&lt;br /&gt;&lt;br /&gt;Replace &quot;75 6A&quot; with &quot;90 90&quot;</description><link>http://bwgypyth.blogspot.com/2016/10/howto-disabling-checksum-checks-in.html</link><author>noreply@blogger.com (bwgypyth)</author><thr:total>1</thr:total></item><item><guid isPermaLink="false">tag:blogger.com,1999:blog-5998090735925918818.post-3808813700505913371</guid><pubDate>Sat, 25 Apr 2015 19:54:00 +0000</pubDate><atom:updated>2015-04-25T12:54:30.016-07:00</atom:updated><title>Moving the code from gitorious to gitlab</title><description>As some may have known: gitorious is shutting down. I decided to move our code over to gitlab. You can find it at:&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;a href=&quot;https://gitlab.com/groups/lotro&quot;&gt;https://gitlab.com/groups/lotro&lt;/a&gt;&lt;/div&gt;</description><link>http://bwgypyth.blogspot.com/2015/04/moving-code-from-gitorious-to-gitlab.html</link><author>noreply@blogger.com (bwgypyth)</author><thr:total>6</thr:total></item><item><guid isPermaLink="false">tag:blogger.com,1999:blog-5998090735925918818.post-8595848384545881307</guid><pubDate>Sun, 15 Jun 2014 17:50:00 +0000</pubDate><atom:updated>2014-06-15T10:50:03.702-07:00</atom:updated><title>State of the project</title><description>Dear readers,&lt;br /&gt;&lt;br /&gt;I&#39;ve continuously been asked whether or not this project is still alive. I&#39;m trying to clarify the situation:&lt;br /&gt;&lt;br /&gt;1.) I (bwgypyth) am no longer working on disassemling the protocol or creating a free server.&lt;br /&gt;&lt;br /&gt;2.) xbadc0de succeeded in understanding the protocol (encryption and checksumming) and was able to create a minimal server. If anyone doubts this drop me an email (bwgypyth@gmx.net) and I will send you a screenshot to prove it (I&#39;m not going to put the screenshot here). He visits from time to time #lotroemu on EFnet, but never shared any code with me. As far as I know he built the server in C++ on Windows and ported it over to Linux as well.&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: left;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: left;&quot;&gt;I am unwilling to redo the same work he did. If anyone is able to continue the project: He is. I can only hope he is going to share the code with us at any point in the future.&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: left;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: left;&quot;&gt;I&#39;ll still be monitoring this blog and will visit #lotroemu more often, but it&#39;s hard to do so working on two jobs 14 hours a day.&lt;/div&gt;</description><link>http://bwgypyth.blogspot.com/2014/06/state-of-project.html</link><author>noreply@blogger.com (bwgypyth)</author><thr:total>11</thr:total></item><item><guid isPermaLink="false">tag:blogger.com,1999:blog-5998090735925918818.post-2605167476426575707</guid><pubDate>Fri, 04 Oct 2013 19:34:00 +0000</pubDate><atom:updated>2013-10-04T12:34:22.263-07:00</atom:updated><title>Finging strings in packets</title><description>As mentioned earlier the server will send some strings to the client to display. Today we&#39;ll take a look at how he does that and how.&lt;br /&gt;&lt;br /&gt;First of all let&#39;s take a look how the strings are stored. I used &lt;a href=&quot;http://lotrounpacker.ucoz.com/&quot;&gt;lotrounpacker &lt;/a&gt;to take a look at the clients data. The site provides two binaries, the dat-unpacker and the localedata-extractor. The first one can be used to unpack&amp;nbsp;client_local_English.dat, the later one will generate a large text file with all the strings. So how do we achieve that?&lt;br /&gt;&lt;br /&gt;First of all copy&amp;nbsp;DAT_UNPACKER.exe and&amp;nbsp;datexport.dll to the root folder of LOTRO (it&#39;s a .NET 4 binary). After this simply call the binary from a commandline:&lt;br /&gt;&lt;blockquote class=&quot;tr_bq&quot;&gt;DAT_UNPACKER.exe client_local_English.dat&lt;/blockquote&gt;This command will run for some time (something like 10 mins), depending on your hardware and fragmentation of your hard disk. It will also eat about 600MB of disk. Once the command is finished you should have folder: data\client_local_English\2XXXXXXX\25XXXXXX\250XXXXX&lt;br /&gt;&lt;br /&gt;Extract the&amp;nbsp;LOCALDATAEXTRACTOR.exe into that directory and execute it&amp;nbsp;(again a .NET 4 binary). It will generate the 30MB text file LocalData.txt containing all the strings. You can now browse this file in something capable dealing with larger text files (i.e. not notepad).&lt;br /&gt;&lt;br /&gt;Now that we have the strings, how do we find out what the server is telling us? Basically the most simple way is to search for &quot;25&quot; in packtes. If we take the first &lt;a href=&quot;http://bwgypyth.appspot.com/packet.jsp?packet=59003&quot;&gt;0x01000006&lt;/a&gt; packet from the server and search for &quot;25&quot;, we will find one occurence. If you now read 5 bytes backwards starting from the byte we found, we will read&amp;nbsp;250001FE0A. So we take a look at the LocaleData.txt to find &quot;Authentifizierung wird überprüft ...&quot; (in case of the client_local_DE, somehow the strings are wrong when using client_local_English). This is exactly the string the client is displaying during startup.&lt;br /&gt;&lt;br /&gt;I also used a disassembler (ILSpy) on both binaries. The &lt;a href=&quot;https://gitorious.org/lotro/lotro-unpacker&quot;&gt;result&lt;/a&gt; does not provide us anything so far, but we might need to parse the files at a later point when the server is maturing. So far there still is a compile error due to an issue in the disassembling, but so far the code looks usable.</description><link>http://bwgypyth.blogspot.com/2013/10/finging-strings-in-packets.html</link><author>noreply@blogger.com (bwgypyth)</author><thr:total>14</thr:total></item><item><guid isPermaLink="false">tag:blogger.com,1999:blog-5998090735925918818.post-7661908294820483908</guid><pubDate>Thu, 03 Oct 2013 22:19:00 +0000</pubDate><atom:updated>2013-10-03T15:19:11.996-07:00</atom:updated><title>Analyzing the initial connection packets</title><description>I&#39;ve spent the day analyzing the initial startup packets and how they are built up. First of all let&#39;s take a look at the order of the first seven packets:&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;http://1.bp.blogspot.com/-MJ4v60ijaLc/Uk3oRumHE8I/AAAAAAAAAAc/A3GHKIqnYmQ/s1600/chart.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;http://1.bp.blogspot.com/-MJ4v60ijaLc/Uk3oRumHE8I/AAAAAAAAAAc/A3GHKIqnYmQ/s1600/chart.png&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: left;&quot;&gt;The client starts by sending the server a &lt;a href=&quot;http://bwgypyth.appspot.com/packet.jsp?packet=59002&quot;&gt;0x00010000&lt;/a&gt; packet. This packet contains the clients version, the locale timestamp of the server in UTC and the login token obtained from the GLS server (this is the central server you are using for your login).&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: left;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: left;&quot;&gt;The server answers this by a &lt;a href=&quot;http://bwgypyth.appspot.com/packet.jsp?packet=58002&quot;&gt;0x00040000&lt;/a&gt; packet. This packets contains identifiers for the server, some seemingly random data, a test token to be sent back by the client, necessary instructions for checksumming and a constant.&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: left;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: left;&quot;&gt;Now the client will send a &lt;a href=&quot;http://bwgypyth.appspot.com/packet.jsp?packet=63001&quot;&gt;0x00080000&lt;/a&gt; packet to the server. The packet contains the test token from the server in reversed form and an unknown constant. From now on the connection is established and packets will be sent encrypted and properly checksummed.&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: left;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: left;&quot;&gt;After this step the server will start sending a large block of data, namely data worth 4 packets. The server will initiate this transfer with a &lt;a href=&quot;http://bwgypyth.appspot.com/packet.jsp?packet=59003&quot;&gt;0x01000006&lt;/a&gt; packet. This packet, again, constains the server identification and (at least in the case of my account) always the same data. The following two 0x00000006 (&lt;a href=&quot;http://bwgypyth.appspot.com/packet.jsp?packet=65001&quot;&gt;1&lt;/a&gt;, &lt;a href=&quot;http://bwgypyth.appspot.com/packet.jsp?packet=66001&quot;&gt;2&lt;/a&gt;) packets are the same for my account no matter which server I chose. After this there always is another 0x00000006 packet, but it differes heavily depending on the server (or maybe other facts).&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: left;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: left;&quot;&gt;Further investigation is necessary, especially if the packets differ depending on the language of the client. It simply might be the case that Gwaihir has more information to tell than Vanyar, but this is unlikely. From what I remember we already know that these packets contain the strings (or better said the number of the string in a large list of strings known to the client) the client will display during the startup.&lt;/div&gt;&lt;br /&gt;</description><link>http://bwgypyth.blogspot.com/2013/10/analyzing-initial-connection-packets.html</link><author>noreply@blogger.com (bwgypyth)</author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://1.bp.blogspot.com/-MJ4v60ijaLc/Uk3oRumHE8I/AAAAAAAAAAc/A3GHKIqnYmQ/s72-c/chart.png" height="72" width="72"/><thr:total>0</thr:total></item><item><guid isPermaLink="false">tag:blogger.com,1999:blog-5998090735925918818.post-5972978791913032863</guid><pubDate>Mon, 30 Sep 2013 19:41:00 +0000</pubDate><atom:updated>2013-09-30T12:42:24.252-07:00</atom:updated><title>Initial analysis of the ping-pong packets</title><description>LOTRO sends &quot;ping-pong&quot; packets between the client and the server to verify the connection is established and both sides are working. These happen in the background without any user interaction. And these also happen in the menu. As far as I understood it so far, the client sends a &quot;ping-packet&quot; to the server and the server &quot;pongs&quot; it.&lt;br /&gt;So far I&#39;ve seen the following types of ping-pong-packets:&lt;br /&gt;&lt;h4&gt;Fast-ping-pong (0x08004002)&lt;/h4&gt;&lt;a href=&quot;http://bwgypyth.appspot.com/packet.jsp?packet=46004&quot;&gt;This packet&lt;/a&gt; contains 10 bytes of data. The first 4 bytes is the sequence number of the last packet seen from the server (e.g. the last packet from the server was 0x0000001F, so this byte sequence will be the four bytes).&lt;br /&gt;This is followed by 6 bytes which are currently unknown. The first four bytes always seem to be a number where only the first byte varies. Their purpose is completely unknown.&lt;br /&gt;The last two bytes of these unknown bytes seem always to be increasing in small steps (between 1 and 4) so it might be the amount of seconds since the client started or even the sum of all bytes sent or something similar.&lt;br /&gt;0x08004002 packets are (almost) always answered by the server with the same type of packet.&lt;br /&gt;&lt;h4&gt;Full-ping-pong (0x0B004002)&lt;/h4&gt;&lt;a href=&quot;http://bwgypyth.appspot.com/packet.jsp?packet=53002&quot;&gt;This packet&lt;/a&gt; contains 22 bytes of data. The first 4 are againt the sequence number from the server. This is followed by a constant&amp;nbsp;A§Úõ (at least during my capture) and a few other bytes. The byte at 0x1C always is the same value as the one at 0x28. The next 3 bytes are unknown, but the first always seems to be 0xA0. It might be that this might change once the last 2 bytes of the packet gets larger than 0xFF. Bytes 0x20 to 0x23 is an (increasing?) number that the server will have to put into his reply.&lt;br /&gt;Again the packet ends with 6 bytes, which seem to be the same as in the 0x08004002 packet.&lt;br /&gt;This packet is answered by a 0x0C0040002 packet.&lt;br /&gt;&lt;h4&gt;Full-ping-pong-repsonse (0x0C004002)&lt;/h4&gt;&lt;a href=&quot;http://bwgypyth.appspot.com/packet.jsp?packet=42003&quot;&gt;This packet&lt;/a&gt; is the repsonse of the server to the clients 0x0B004002 packet. It constists of 18 bytes of data. The first 4 bytes are again the sequence number of the last packet the server saw from the client. The following 4 bytes are the copy of the bytes 0x20 to 0x23 from the clients packet. The following four bytes are unknown. Again the packet ends with 6 bytes, which seem to be the same as in the 0x08004002 and the 0x0B004002 packets.&lt;br /&gt;&lt;h4&gt;Non-sequentiell-ping-pong&#39;s (0x0?000002)&lt;/h4&gt;These packets seem to be the same as their 0x0?004002 counterparts, except for the facts they are missing the 4 sequence number bytes at the beginning of the data. It is unclear why and when these are issued.</description><link>http://bwgypyth.blogspot.com/2013/09/initial-analysis-of-ping-pong-packets.html</link><author>noreply@blogger.com (bwgypyth)</author><thr:total>0</thr:total></item><item><guid isPermaLink="false">tag:blogger.com,1999:blog-5998090735925918818.post-6252509659905360456</guid><pubDate>Fri, 06 Sep 2013 07:29:00 +0000</pubDate><atom:updated>2013-09-06T00:29:30.363-07:00</atom:updated><title>Clarification on the projects status</title><description>First of all thanks for the comments that show your interest! Unlike you might have thought I did not stop working on analyzing the packets sent between the client and the server. It&#39;s just that &quot;real live&quot; sometimes gets in the way ;-)&lt;br /&gt;&lt;br /&gt;So I recently started capturing packets again to see how they are assembled. This is a time consuming process but I&#39;ll explain the very easy steps.&lt;br /&gt;&lt;br /&gt;1.) Clone the repository from &lt;a href=&quot;http://gitorious.org/lotro/lotro-server&quot;&gt;http://gitorious.org/lotro/lotro-server&lt;/a&gt;&lt;br /&gt;2.) Import the project into your Visual Studio (Monodevelop is not supported right now)&lt;br /&gt;3.) Run the Project&amp;nbsp;LOTROPacketCaptureAndAutoDecryption&lt;br /&gt;4.) Launch the game and &quot;do something&quot;&lt;br /&gt;5.) Take a look at the packages generated by&amp;nbsp;LOTROPacketCaptureAndAutoDecryption (you can also upload them to&amp;nbsp;&lt;a href=&quot;http://bwgypyth.appspot.com/&quot;&gt;http://bwgypyth.appspot.com/&lt;/a&gt;&amp;nbsp;but be aware that they might contain sensitive data)&lt;br /&gt;6.) Repeat steps 3.) to 5.) over and over again&lt;br /&gt;&lt;br /&gt;We already know some of the details on the decrypted packets, like to be seen in&amp;nbsp;&lt;a href=&quot;http://bwgypyth.appspot.com/packet.jsp?packet=35004&quot;&gt;http://bwgypyth.appspot.com/packet.jsp?packet=35004&lt;/a&gt;. All of the analyzed packets so far contain a header and data block. The header always is 20 bytes long (the initial packets sent have a header of 22 bytes, but more on that in a later post) and describes the data.&lt;br /&gt;&lt;br /&gt;The data packets themselves can be distinguished by the &quot;root command&quot; (as we call it). This defines the type of data that is sent. So far we know the most about 0x00000006 packets, which are used when doing a character creation request.&lt;br /&gt;&lt;br /&gt;The server and client also exchange &quot;ping pong&quot; packets to verify they can talk to each other and didn&#39;t loose the connection. I case someone is interested in understanding the process you can try to identify these packets (simply do nothing in the game and these will be the most frequent packages) and analyze how they are built up. Feel free to ask questions regarding this process in the comments and I&#39;ll try to answer them as quickly as possible.&lt;br /&gt;&lt;br /&gt;And a quick sidenote: Everything we did so far is open source and can be found at&amp;nbsp;&lt;a href=&quot;http://gitorious.org/lotro&quot;&gt;http://gitorious.org/lotro&lt;/a&gt;. Feel free to play with the code and add things. The web application for visualizing packets is written in Java while the dumping of packets is written in C#. Both of these languages are pretty easy to learn (you don&#39;t have to deal with memory allocation), but feel free to contribute in whichever language you prefer.</description><link>http://bwgypyth.blogspot.com/2013/09/clarification-on-projects-status.html</link><author>noreply@blogger.com (bwgypyth)</author><thr:total>1</thr:total></item><item><guid isPermaLink="false">tag:blogger.com,1999:blog-5998090735925918818.post-4428444171825395359</guid><pubDate>Fri, 22 Mar 2013 00:16:00 +0000</pubDate><atom:updated>2013-03-21T17:16:01.574-07:00</atom:updated><title>Regarding encrypted and unencrypted packets</title><description>When tAmMo did his initial analysis of the packets he figured that headers during setup were 22 bytes long while the ones afterwards are only 20 bytes long. Until recently we went on with this scheme. When I was dumping the traffic between the server and my client I sometimes got very strange packets. These packets seemed to have the 22 bytes header! This did not make sense because only the unencrypted packets have 22 bytes in the header. Also these packets failed to make sense after decryption. Then it struck xbadc0de and myself: The server sometime decides zu send unencrypted packets!&lt;br /&gt;&lt;br /&gt;So what does this mean: We don&#39;t have to figure out encryption. My dummy test server (which is just able to replay captured data) just sends out unencrypted packets and the clients just uses them. As easy as is. This saves us lots of time figuring out encryption, saves us compution time on our server and also means we don&#39;t harm the productive servers.&lt;br /&gt;&lt;br /&gt;But how does the client detect an unencrypted packet coming in: Well, it&#39;s pretty easy. The third byte in the packet header is set to 0x00. It took me long hours to figure that out (and xbadc0de gave me the necessary hints, thanks!). I patched our decryption logic to deal with this fact.&lt;br /&gt;&lt;br /&gt;&lt;a href=&quot;https://gitorious.org/lotro/lotro-server/commit/52d3120caf0413e395549ba68f395cf88568ebe9&quot;&gt;https://gitorious.org/lotro/lotro-server/commit/52d3120caf0413e395549ba68f395cf88568ebe9&lt;/a&gt; </description><link>http://bwgypyth.blogspot.com/2013/03/regarding-encrypted-and-unencrypted.html</link><author>noreply@blogger.com (bwgypyth)</author><thr:total>18</thr:total></item><item><guid isPermaLink="false">tag:blogger.com,1999:blog-5998090735925918818.post-7419702594150349774</guid><pubDate>Mon, 18 Mar 2013 23:41:00 +0000</pubDate><atom:updated>2013-03-18T16:41:08.782-07:00</atom:updated><title>Improving communication using IRC</title><description>Until now the complete conversation was done using comments on this blog. This has a severe impact on communication latency because answers to the simplest questions just take very long. Next to that answers to blog posts are often done anonymously which causes the commenter not to get informed by email about responses.&lt;br /&gt;&lt;br /&gt;Today we started to improve that situation by using the IRC channel #lotroemu on the efnet servers. The idea was initially brought up by xbadc0de and him pointing out the massive problems in our communication style described above. We had some good discussion on the packets and I gained some great insight on how they are made up (and we also agreed on a common wording so we actually talk the same language).&lt;br /&gt;&lt;br /&gt;From now on I&#39;ll try to join that channel as often as possible and I can only recommend this for everyone interested, too. Feel free to ask questions. Feel free to share opinions. Feel free to give advice.&lt;br /&gt;&lt;br /&gt;See you on IRC.</description><link>http://bwgypyth.blogspot.com/2013/03/improving-communication-using-irc.html</link><author>noreply@blogger.com (bwgypyth)</author><thr:total>4</thr:total></item><item><guid isPermaLink="false">tag:blogger.com,1999:blog-5998090735925918818.post-8938509078546006601</guid><pubDate>Sun, 17 Mar 2013 18:48:00 +0000</pubDate><atom:updated>2013-03-17T11:48:28.811-07:00</atom:updated><title>New server code uploaded</title><description>Today tAmMo sent me over his latest code which I uploaded to our &lt;a href=&quot;https://gitorious.org/lotro/lotro-server&quot;&gt;git repository&lt;/a&gt;. The code should match the state of the binary used to capture the packets earlier, but fails to compile right now due to incompatibilities with the Helper.dll (even the one from the server does not work).&lt;br /&gt;&lt;br /&gt;If you want to use the code the problems right now are:&lt;br /&gt;&lt;br /&gt;Helper.HelperMethods.Instance does not exist.&lt;br /&gt;Helper.BEBinaryWriter.WriteUInt16BEX does not exist.&lt;br /&gt;&lt;br /&gt;Other than that the code import seems to have worked flawless :-)</description><link>http://bwgypyth.blogspot.com/2013/03/new-server-code-uploaded.html</link><author>noreply@blogger.com (bwgypyth)</author><thr:total>2</thr:total></item><item><guid isPermaLink="false">tag:blogger.com,1999:blog-5998090735925918818.post-1838063560071403083</guid><pubDate>Sun, 17 Mar 2013 17:51:00 +0000</pubDate><atom:updated>2013-03-17T10:51:52.916-07:00</atom:updated><title>Analyzing the character creation</title><description>Now that we have a server working for logins it&#39;s time to start analyzing the packets. Since we currently only reach the character creation screen I took the time to analyze the packet sent by the client to the server when creating the client. This packet already has a wide range of variety so I started looking at creating a male, human burglar from Bree.&lt;br /&gt;&lt;br /&gt;You can take a look at this analysis at the following page:&lt;br /&gt;&lt;a href=&quot;http://bwgypyth.appspot.com/packet.jsp?packet=305&quot;&gt;http://bwgypyth.appspot.com/packet.jsp?packet=305&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;I was already able to identfy some parts of the packet, e.g. hairtype, headtyp, mouthtype, etc. There are some interesting things to be seen in the different packets. First of all the packet differs even on same input data. Take you look at:&lt;br /&gt;&lt;br /&gt;&lt;a href=&quot;http://bwgypyth.appspot.com/packet.jsp?packet=9001&quot;&gt;http://bwgypyth.appspot.com/packet.jsp?packet=9001&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;This is exactly the same action as performed in the other packet (creating a male, human burglar from Bree) but is padded with addition unknown data. So first of all we needed to identify the magic number in the packet that tells the server to create a character. Since we are assuming that we are facing an opcode based network protocol I was looking for a repeating sequence, named &lt;i&gt;opcode&lt;/i&gt;.&lt;br /&gt;For now we assume that opcodes are either 4 bytes long (or 2 bytes prefixed by the number of opcodes in the packet). 0x&lt;span class=&quot;hoverable data&quot;&gt;&lt;span class=&quot;hoverable data0&quot;&gt;&lt;span class=&quot;decoded_or_hex_element&quot; id=&quot;hex_element_1A&quot;&gt;01&lt;/span&gt;&lt;span class=&quot;decoded_or_hex_element&quot; id=&quot;hex_element_1B&quot;&gt; 0x00 0x&lt;/span&gt;&lt;span class=&quot;decoded_or_hex_element&quot; id=&quot;hex_element_1C&quot;&gt;01&lt;/span&gt; 0x&lt;span class=&quot;decoded_or_hex_element&quot; id=&quot;hex_element_1D&quot;&gt;04 was the first data packet (after the 20 bytes of header code) in the the shortest captures. This opcode also appeared in all captures, so I assume this is the opcode to start a character creation.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;hoverable data&quot;&gt;&lt;span class=&quot;hoverable data0&quot;&gt;&lt;span class=&quot;decoded_or_hex_element&quot; id=&quot;hex_element_1D&quot;&gt;This opcode (which appears to be the last opcode in the packet) is followed by 147 bytes of data for a male humanoid burglar character. Take a look at the data I gathered and please verify my assumptions. The best way to do this is by comparing the data (e.g. by using Meld which is an awesome diff viewer).&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;hoverable data&quot;&gt;&lt;span class=&quot;hoverable data0&quot;&gt;&lt;span class=&quot;decoded_or_hex_element&quot; id=&quot;hex_element_1D&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;hoverable data&quot;&gt;&lt;span class=&quot;hoverable data0&quot;&gt;&lt;span class=&quot;decoded_or_hex_element&quot; id=&quot;hex_element_1D&quot;&gt;Another interesting catch is that female humanoid characters are created using shorter packets (only 128 Bytes). One of the reasons seems to be that the GUI lacks a method to add facial hair which seems also to be lacking in the packet (dwarf ladies might be different, I haven&#39;t checked that yet).&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;hoverable data&quot;&gt;&lt;span class=&quot;hoverable data0&quot;&gt;&lt;span class=&quot;decoded_or_hex_element&quot; id=&quot;hex_element_1D&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;hoverable data&quot;&gt;&lt;span class=&quot;hoverable data0&quot;&gt;&lt;span class=&quot;decoded_or_hex_element&quot; id=&quot;hex_element_1D&quot;&gt;Have fun browsing the packets. I&#39;m planning on investigating this packet further and keep you updated.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;</description><link>http://bwgypyth.blogspot.com/2013/03/analyzing-character-creation.html</link><author>noreply@blogger.com (bwgypyth)</author><thr:total>2</thr:total></item><item><guid isPermaLink="false">tag:blogger.com,1999:blog-5998090735925918818.post-2091417808896830404</guid><pubDate>Sat, 16 Mar 2013 14:45:00 +0000</pubDate><atom:updated>2013-03-16T07:45:32.540-07:00</atom:updated><title>Improving the packet analyzer</title><description>The packet web based packet analyzer gained one important feature today: interactivity. Until now it was just displaying a single packet. You couldn&#39;t do anything except look at it.&lt;br /&gt;&lt;br /&gt;Today I finished converting this simple HTML-page into a full blown wep application. It is now possible to upload new packets and annotate them! The whole workflow is still rough around the edges but it&#39;s already a usable prototype. I uploaded the first 2 packages as found in the PDF and also corrected them for some mistakes (either in the PDF or made by me).&lt;br /&gt;&lt;br /&gt;The model behind this application is pretty basic right now. The top-level entity is &#39;Packet&#39; which represents a single network packet. Each packet can have one or more &#39;Analysis&#39; attached, which group together &#39;AnalysisEntries&#39;. An entry itself basically is a description of the bytes found in the packet.&lt;br /&gt;&lt;br /&gt;Please test the application and upload your data to: &lt;a href=&quot;http://bwgypyth.appspot.com/&quot;&gt;http://bwgypyth.appspot.com/&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;The next step to be done is allowing more than one analysis per packet and to comment on packets, analyses and entries. And also editing existing entries is planned.&lt;br /&gt;&lt;br /&gt;Next to that we now have a working server that is capable of dealing with starting the client, character selection and character creation! This really is awesome news and a major achievement of tAmMo. We&#39;ll upload the updated code as soon as possible. I&#39;ll let you know when this happens.&lt;br /&gt;</description><link>http://bwgypyth.blogspot.com/2013/03/improving-packet-analyzer.html</link><author>noreply@blogger.com (bwgypyth)</author><thr:total>2</thr:total></item><item><guid isPermaLink="false">tag:blogger.com,1999:blog-5998090735925918818.post-80596944534929391</guid><pubDate>Sat, 09 Mar 2013 15:32:00 +0000</pubDate><atom:updated>2013-03-16T05:10:55.540-07:00</atom:updated><title>Initial attempt at packet analyzer</title><description>Our biggest issue right now is to understand how the packets are assembled when they are tranfered from and to the server. Our previous attempt was to document the packets within an LibreOffice document hosted in our git repository. Sadly this does not work very well and especially does not scale. Only one developer can work on the document at a time.&lt;br /&gt;&lt;br /&gt;Starting today we are working on a small web based packet analyzer. Right now it is capable of displaying a single annotated packet taken from our current documentation, which is a rather limited functionality. We are working on creating a server backend to store annotated packets so everyone can collaborate and either annotate packets or give feedback to annotated packets. You can take a very brief preview at&amp;nbsp; the following URL:&lt;br /&gt;&lt;br /&gt;&lt;a href=&quot;https://gitorious.org/lotro/lotro-analyzer/blobs/raw/master/packet.html&quot;&gt;https://gitorious.org/lotro/lotro-analyzer/blobs/raw/92df3298baa914602354df7501ea493e305851ca/packet.html&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;Note: The code is currently tested in Google Chrome, Firefox and Internet Explorer. </description><link>http://bwgypyth.blogspot.com/2013/03/initial-attempt-at-packet-analyzer.html</link><author>noreply@blogger.com (bwgypyth)</author><thr:total>10</thr:total></item><item><guid isPermaLink="false">tag:blogger.com,1999:blog-5998090735925918818.post-1649006086242367261</guid><pubDate>Sat, 02 Mar 2013 12:56:00 +0000</pubDate><atom:updated>2013-03-02T05:48:45.272-08:00</atom:updated><title>Updates investigation documents and server code published</title><description>I&#39;m happy to announce that I just published the updated work of tAmMo containing updated documentation and servercode that should hopefully work with the updated network protocol from Riders of Rohan.&lt;br /&gt;&lt;br /&gt;For now we are keeping the encryption/decryption checksum functionality proprierary. The primary reason for this that we don&#39;t want the official servers to get compromised. It is unlikely that one would be able to cheat using this code because we think that the official servers most likely have client packet validation beyond checksumming (e.g. the client sends a movement to the server and the server will validate that it is actually possible and reject it if not, as seen when you &quot;bounce back&quot; in the game). But since we cannot be certain about that we don&#39;t want to harm the official servers.&lt;br /&gt;&lt;br /&gt;I&#39;m in the process of creating proper documentation for how to run a client against your own server which will hopefully released soon.&lt;br /&gt;&lt;br /&gt;For now you can find the code at: &lt;a href=&quot;https://gitorious.org/lotro/lotro-server&quot;&gt;gitorious.org/lotro/lotro-server&lt;/a&gt; </description><link>http://bwgypyth.blogspot.com/2013/03/updates-investigation-documents-and.html</link><author>noreply@blogger.com (bwgypyth)</author><thr:total>6</thr:total></item><item><guid isPermaLink="false">tag:blogger.com,1999:blog-5998090735925918818.post-3653141589936136182</guid><pubDate>Sat, 28 Jul 2012 08:18:00 +0000</pubDate><atom:updated>2012-07-28T01:18:20.101-07:00</atom:updated><title>Revamping the work</title><description>I recently started hacking on lotro again, trying to figure out the checksumming. Right now I fail to understand how it works, eve hough tAmMo left some hints.&lt;br /&gt;&lt;br /&gt;Dear tAmMo, if you read this, please get in contact with me. Thanks!</description><link>http://bwgypyth.blogspot.com/2012/07/i-recently-started-hacking-on-lotro.html</link><author>noreply@blogger.com (bwgypyth)</author><thr:total>40</thr:total></item><item><guid isPermaLink="false">tag:blogger.com,1999:blog-5998090735925918818.post-3579515629820765809</guid><pubDate>Sun, 11 Mar 2012 00:50:00 +0000</pubDate><atom:updated>2012-03-10T16:50:39.492-08:00</atom:updated><title>Decryption and encryption progress</title><description>Recently a commenter name tAmMo started playing around with how encryption and decryption of the packets might work. He made several comments about his progress and just yesterday he posted something unexpected: Source code related to client packet decryption.&lt;br /&gt;&lt;br /&gt;So what does this mean? Not much for the &quot;end user&quot;, but a great deal for researchers. Also tAmMo did not release the complete code, especially the part of encrypting packets to be sent to the server. This could be used for hacks or to create a private server which is not the intention of this attempt.&lt;br /&gt;&lt;br /&gt;The code is hosted at https://gitorious.org/lotro/lotro-tools for now. Take a look at it, play with it, and keep us updated using comments!</description><link>http://bwgypyth.blogspot.com/2012/03/decryption-and-encryption-progress.html</link><author>noreply@blogger.com (bwgypyth)</author><thr:total>5</thr:total></item><item><guid isPermaLink="false">tag:blogger.com,1999:blog-5998090735925918818.post-8862114303370807474</guid><pubDate>Sat, 10 Dec 2011 22:39:00 +0000</pubDate><atom:updated>2011-12-10T14:59:22.744-08:00</atom:updated><title>Regarding compressed communication</title><description>This blog has been inactive for quite a while, but users where still commenting. I didn&#39;t have the time to respond, but I kept watching the progress. Now is the time to sum up some of the comments.&lt;br /&gt;&lt;br /&gt;Recently the idea came up if the communication between the client and the server might be compressed (additionally to being encrypted). I don&#39;t think this is the case. From my understanding the game does most likely use opcodes for data exchange. The amount of data is not very high so having the cpu overhead of doing stream encrypting does not really bring much benefit.&lt;br /&gt;&lt;br /&gt;Our commenters have also tested to use a &quot;verbose&quot; version of the zlib that writes the protocol of the called method. From what we could observe only calls to &quot;decompress&quot; were made. Therefore it&#39;s most likely that the communication is only RC4 encrypted data.&lt;br /&gt;&lt;br /&gt;I also was contacted by an Austrian developer that is looking into doing the same attempt we are doing for DDO. He is using easyhook (http://easyhook.codeplex.com/) to trace the calls. He focused on CryptImportKey() and CryptGenKey() to receive the private/public keys and the RC4 stream cipher. This might be an option for Windows users to figure out what the client is doing (Linux users can always use wine and hack it in whatever way they prefer).&lt;br /&gt;&lt;br /&gt;I&#39;m looking forward to what else our readers might come up with. Feel free to comment on this blog for whatever reason you like, e.g. connecting to other developers.</description><link>http://bwgypyth.blogspot.com/2011/12/regarding-compressed-communication.html</link><author>noreply@blogger.com (bwgypyth)</author><thr:total>14</thr:total></item><item><guid isPermaLink="false">tag:blogger.com,1999:blog-5998090735925918818.post-183851944445843602</guid><pubDate>Sat, 09 Oct 2010 14:41:00 +0000</pubDate><atom:updated>2010-10-09T07:41:37.986-07:00</atom:updated><title>On to the character selection</title><description>As you might have seen in this &lt;a href=&quot;http://www.youtube.com/watch?v=aI236KWyKQo&quot;&gt;this video&lt;/a&gt; we got to the point of entering the character selection screen. This is a really good start. Today I got the latest copy of code by the videos author. I&#39;m currently reviewing it and will hopefully put it to gitorious later.&lt;br /&gt;&lt;br /&gt;The code itself is written using C#. This allows rapid prototyping of applications and good development speed. The code is capable of handling the login but you can&#39;t play the game yet. It basically is split into 2 states&lt;br /&gt;&lt;ul&gt;&lt;li&gt;loginStage&lt;/li&gt;&lt;li&gt;marginStage&lt;/li&gt;&lt;/ul&gt;During the loginState 15 packets will be sent by the server. In the following marginState 4 packets will be sent. We don&#39;t handle ping-pong-packets to verify the server is up and running yet. Also right now the code is not multi threaded.&lt;br /&gt;&lt;br /&gt;The biggest downside right now is that we can send the packets the client expects but don&#39;t know what they mean in detail.&lt;br /&gt;&lt;br /&gt;So stay tuned for further updates.</description><link>http://bwgypyth.blogspot.com/2010/10/on-to-character-selection.html</link><author>noreply@blogger.com (bwgypyth)</author><thr:total>18</thr:total></item></channel></rss>